import{_ as l,r as i,o as u,c as p,a as t,b as e,d as s,w as o,e as r}from"./app.c515eac2.js";const c={},d=t("h1",{id:"unit-testing",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#unit-testing","aria-hidden":"true"},"#"),e(" Unit Testing")],-1),h=t("p",null,"Our unit test suites are primarily built on top of our storybook stories, as a lot of the setup leg work has already been done within this process, e.g. a default story, a story with a prop set, etc.",-1),m={href:"https://jestjs.io/",target:"_blank",rel:"noopener noreferrer"},f={href:"https://jestjs.io/",target:"_blank",rel:"noopener noreferrer"},k=t("h2",{id:"packages",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#packages","aria-hidden":"true"},"#"),e(" Packages")],-1),b=t("h3",{id:"vue-storybook-test-utils",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#vue-storybook-test-utils","aria-hidden":"true"},"#"),e(" Vue Storybook Test Utils")],-1),v={href:"https://github.com/netsells/vue-storybook-test-utils",target:"_blank",rel:"noopener noreferrer"},g={href:"https://vue-test-utils.vuejs.org/",target:"_blank",rel:"noopener noreferrer"},y=r(`<p>For further details and usage check out the module README.</p><h2 id="format" tabindex="-1"><a class="header-anchor" href="#format" aria-hidden="true">#</a> Format</h2><h3 id="file-convention" tabindex="-1"><a class="header-anchor" href="#file-convention" aria-hidden="true">#</a> File Convention</h3><p>Test files should be suffixed with <code>.spec.js</code> and should match the name of the file being tested. They should be placed alongside the source file in your application. For example, if we were to have a <code>TextInput.vue</code> component, our file structure would look something like so:</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>├─ TextInput/
│  ├─ TextInput.vue
│  ├─ TextInput.spec.js
│  └─ TextInput.stories.js
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Doing so makes it easier to see where the tests are located for each part of your application.</p><h3 id="test-structure" tabindex="-1"><a class="header-anchor" href="#test-structure" aria-hidden="true">#</a> Test Structure</h3><p>It’s recommended that you structure your tests similar to a UAT. For example, at the root level you would specify your component, and then you would nest your tests as if they were a written sentence. For example, take the following sentence:</p><blockquote><p><strong>On the TextInput component, when the <code>disabled</code> prop is passed, the input will become disabled.</strong></p></blockquote><p>What we end up with are three pieces of information.</p>`,10),_=t("code",null,"TextInput",-1),w=t("code",null,"disabled",-1),x=r(`<p>Given, this information we can structure our test like so:</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">describe</span><span class="token punctuation">(</span><span class="token string">&#39;TextInput&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// the entity</span>
    <span class="token function">describe</span><span class="token punctuation">(</span><span class="token string">&#39;when the \`disabled\` prop is provided&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// the functionality</span>
        <span class="token function">test</span><span class="token punctuation">(</span><span class="token string">&#39;the input is disabled&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// the outcome</span>
            <span class="token comment">// Run tests to satisfy the UAT</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The idea behind this format is to avoid cases where you might have a test named <code>updates data appropriately</code>. What does “appropriately” mean? If a new developer were to modify this component and update the test in future would they know what the individual requirements of the component are?</p><p>Eventually you will end up with a complete, living UAT document within the codebase.</p><h3 id="fixtures" tabindex="-1"><a class="header-anchor" href="#fixtures" aria-hidden="true">#</a> Fixtures</h3><p>When testing against data, rather than hardcoding your data within your test, it&#39;s better to move this data to a <code>fixture</code>. A fixture is an immutable dataset that your tests are based on to mimic real data. For instance if you have a component which takes data from an endpoint and populates a users table, you might have a <code>users.json</code> fixture with your static data. You would then pull this into your test instead.</p><p>Fixtures should be placed in <code>&lt;root&gt;/tests/fixtures/</code>.</p><div class="custom-container warning"><p class="custom-container-title">WARNING</p><p>It&#39;s important that your fixture remains immutable as to not introduce any essence of unpredictability into your tests</p></div>`,8);function T(I,j){const n=i("ExternalLinkIcon"),a=i("badge");return u(),p("div",null,[d,h,t("p",null,[e("Tests should be written using "),t("a",m,[e("jest"),s(n)]),e(" .")]),t("p",null,[e("Any non-component tests should follow the same format as below, but interact with "),t("a",f,[e("jest"),s(n)]),e(" directly.")]),k,b,t("p",null,[e("Link: "),t("a",v,[e("@netsells/vue-storybook-test-utils"),s(n)])]),t("p",null,[e("Most of your test composition and variants (e.g. props, slots) is already setup as part of storybook for use in component-first development and Visual Regression Testing process. It makes little sense to do this setup twice. This module allows you to pass your stories directly to the "),t("a",g,[e("@vue/test-utils"),s(n)]),e(" package and have the wrappers automatically generated with your provided props and story markup.")]),y,t("ul",null,[t("li",null,[e("The "),s(a,{vertical:"middle"},{default:o(()=>[e("entity")]),_:1}),e(" being tested: "),_]),t("li",null,[e("The "),s(a,{vertical:"middle"},{default:o(()=>[e("functionality")]),_:1}),e(" being tested: the "),w,e(" prop being passed")]),t("li",null,[e("The desired "),s(a,{vertical:"middle"},{default:o(()=>[e("outcome")]),_:1}),e(": the input will become disabled")])]),x])}const A=l(c,[["render",T],["__file","unit-testing.html.vue"]]);export{A as default};
