import{_ as a,r as n,o as i,c as s,a as r,b as e,d as o,w as d,e as l}from"./app.33d3398e.js";const c={},h=l(`<h1 id="clean-architecture" tabindex="-1"><a class="header-anchor" href="#clean-architecture" aria-hidden="true">#</a> Clean Architecture</h1><p>Android projects should use the Clean Architecture to ensure maintainability and testability. In other words, the project should be split into <strong>features</strong> with each feature containing a <strong>data</strong> layer, a <strong>domain</strong> layer, and a <strong>presentation</strong> layer. Additionally, a <code>core</code> directory at the root of the source code directory can hold project-wide code where appropriate.</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>+--- src
    +--- core
    +--- features
        +--- my_feature
            +--- data
                +--- models
                    ** Classes which extend entities and provide additional conversion code **
                +--- datasources
                    ** Code for retrieving data from external sources **
                +--- repositories
                    ** Implementations of the repository interfaces from the domain layer **
            +--- domain
                +--- entities
                    ** Simple data classes with no ties to data or presentation layers **
                +--- repositories
                    ** Repository interfaces which will be implemented in the data layer **
                +--- usecases
                    ** Use cases, for use by the presentation layer **
            +--- presentation
                ** Activities, fragments, adapters, and views **
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><em>Consider splitting your project into an <code>app</code> module, containing the data and presentation layers, and a <code>core</code> module containing the domain layer.</em></p><h2 id="domain-layer" tabindex="-1"><a class="header-anchor" href="#domain-layer" aria-hidden="true">#</a> Domain Layer</h2><p>When writing a feature it&#39;s sensible to write the domain layer first.</p><p>Start with <strong>entities</strong>, which should be simple Kotlin data classes representing the data this feature is working with.</p><p>Then create <strong>repositories</strong>, which should be <strong>interfaces</strong> or <strong>abstract classes</strong> defining the data transactions supported by this feature.</p><p>Then create <strong>use cases</strong>, which are designed to be called by the presentation layer. These should call the <strong>repositories</strong> and return data as the presentation layer requires it. In other words, use cases are delegates for the presentation layer&#39;s business logic.</p><h2 id="data-layer" tabindex="-1"><a class="header-anchor" href="#data-layer" aria-hidden="true">#</a> Data layer</h2><p>The data layer implements the repositories defined in the domain layer. This is done by implementing <strong>data sources</strong>, which fetch data from remote locations like databases and APIs. This data is then passed to the repository implementatations in the form of <strong>models</strong>, which extend the <strong>entities</strong> defined in the domain layer.</p><h2 id="presentation-layer" tabindex="-1"><a class="header-anchor" href="#presentation-layer" aria-hidden="true">#</a> Presentation layer</h2><p>This layer contains all presentation-related code including activities, fragments, viewmodels, adapters etc. It should use <strong>usecases</strong> to interact with the domain layer.</p>`,13);function u(m,p){const t=n("RouterLink");return i(),s("div",null,[h,r("p",null,[e("The presentation layer should be built using "),o(t,{to:"/android/mvvm.html"},{default:d(()=>[e("MVVM")]),_:1}),e(".")])])}const g=a(c,[["render",u],["__file","clean-architecture.html.vue"]]);export{g as default};
