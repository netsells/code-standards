import{_ as e,o as s,c as a,e as n}from"./app.0bb2e6d2.js";const t={},i=n(`<h1 id="general-guidelines" tabindex="-1"><a class="header-anchor" href="#general-guidelines" aria-hidden="true">#</a> General Guidelines</h1><p>All points here here are general guidelines only - break them if you have a good reason (but only if you have a good reason).</p><h2 id="ef-and-db" tabindex="-1"><a class="header-anchor" href="#ef-and-db" aria-hidden="true">#</a> EF and DB</h2><p>DB interaction should be through entity framework - only use custom sql / stored procedure etc. when absolutely necessary.</p><p>Use of automapper projections is strongly encouraged.</p><p>Db interaction should be contained in repository classes</p><p>Primary db interactions should be via ICommonRepository or equivalent.</p><p>Filtering should be done primarily through IEntityFilter implementations. Avoid complex filters - use IMultiPartFilter when possible.</p><p>Ordering should be done primarily through IEntity order implementations.</p><p>Avoid EF includes where possible - nothing outside the repository method which is accessing the db and the service directly cosuming it should assume any navigation properties are populated.</p><h2 id="automapper" tabindex="-1"><a class="header-anchor" href="#automapper" aria-hidden="true">#</a> Automapper</h2><p>Automapper should be used for simple type mappings.</p><p>Mappings from db entities to model should take care to only use simple mappings so they can be executed in SQL by EF.</p><p>Do not put complex logic in automapper profiles - if you need a custom resolver or any services injected then use an explicit mapping service.</p><h2 id="controllers-and-services" tabindex="-1"><a class="header-anchor" href="#controllers-and-services" aria-hidden="true">#</a> Controllers and services</h2><p>Business logic should be kept out of controllers. Controllers should only contain logic for interfacing between request and service actions.</p><p>Entity classes should not be used as request / result models - add a model with a mapping.</p><h2 id="async" tabindex="-1"><a class="header-anchor" href="#async" aria-hidden="true">#</a> Async</h2><p>Where possible, all interactions with external services / dbs / filesystems etc. should be async.</p><p>Avoid using Task.Result or equivalents - use async / await.</p><h2 id="request-validation-and-exceptions" tabindex="-1"><a class="header-anchor" href="#request-validation-and-exceptions" aria-hidden="true">#</a> Request validation and exceptions</h2><p>Where possible requests should be validated.</p><p>Use Fluent Validation.</p><p>Where practical validation should be separated from action logic and performed before any other actions.</p><p>Any caught exceptions should be logged. Don&#39;t swallow exceptions.</p><p>Don&#39;t add try catch blocks which then throw a generic exception e.g.:</p><div class="language-csharp line-numbers-mode" data-ext="cs"><pre class="language-csharp"><code><span class="token keyword">try</span>
<span class="token punctuation">{</span>
	<span class="token comment">//Some stuff</span>
<span class="token punctuation">}</span>
<span class="token keyword">catch</span> 
<span class="token punctuation">{</span>
	<span class="token comment">//Doing this loses the stack trace and all information about the actual error.</span>
	<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">SomethingWentWrongException</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="services-and-dependency-injection" tabindex="-1"><a class="header-anchor" href="#services-and-dependency-injection" aria-hidden="true">#</a> Services and dependency Injection</h2><p>Code should be logically divided into services, connected via interfaces using dependency injection.</p><p>All services should have a single purpose.</p><p>Services should usually only have a few external methods - services with lost of methods generally have too many responsibilities.</p><p>Each logical code area should have its own service registration extension.</p><p>Services should generally be registered as either scoped or transient. Be extremely careful registering anything as static scope.</p><h2 id="external-interactions" tabindex="-1"><a class="header-anchor" href="#external-interactions" aria-hidden="true">#</a> External interactions</h2><p>Interaction with external API or other resources should be implemented behind a facade service. It&#39;s usually impractical to unit test these facade services.</p><h2 id="unit-tests" tabindex="-1"><a class="header-anchor" href="#unit-tests" aria-hidden="true">#</a> Unit Tests</h2><p>Where practical, all code should be unit tested.</p><p>Unit test should be in their own project.</p><p>Each service should have a folder for its unit tests, named after the class e.g. MyClassTests.</p><p>Each public method in a service should have it&#39;s own test file named for the method e.g. GetTheDataTests.</p><p>Services with multiple public methods should have a test base class dealing with initialisation etc.</p><p>Unit test for filters and orders do not need a folder - they can have a single file named for the filter e.g. MyFilterTests.</p><p>Use Moq and FluentAssertions.</p>`,43),o=[i];function r(l,d){return s(),a("div",null,o)}const p=e(t,[["render",r],["__file","general-guidelines.html.vue"]]);export{p as default};
