(window.webpackJsonp=window.webpackJsonp||[]).push([[162],{261:function(t,e,s){"use strict";s.r(e);var a=s(0),n=Object(a.a)({},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"unit-testing"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#unit-testing","aria-hidden":"true"}},[t._v("#")]),t._v(" Unit Testing")]),t._v(" "),s("p",[t._v("Our unit test suites are primarily built on top of our storybook stories, as a lot of the setup leg work has already been done within this process, e.g. a default story, a story with a prop set, etc.")]),t._v(" "),s("p",[t._v("Tests should be written using "),s("a",{attrs:{href:"https://jestjs.io/",target:"_blank",rel:"noopener noreferrer"}},[t._v("jest"),s("OutboundLink")],1),t._v(" .")]),t._v(" "),s("p",[t._v("Any non-component tests should follow the same format as below, but interact with "),s("a",{attrs:{href:"https://jestjs.io/",target:"_blank",rel:"noopener noreferrer"}},[t._v("jest"),s("OutboundLink")],1),t._v(" directly.")]),t._v(" "),s("h2",{attrs:{id:"packages"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#packages","aria-hidden":"true"}},[t._v("#")]),t._v(" Packages")]),t._v(" "),s("h3",{attrs:{id:"vue-storybook-test-utils"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue-storybook-test-utils","aria-hidden":"true"}},[t._v("#")]),t._v(" Vue Storybook Test Utils")]),t._v(" "),s("p",[t._v("Link: "),s("a",{attrs:{href:"https://github.com/netsells/vue-storybook-test-utils",target:"_blank",rel:"noopener noreferrer"}},[t._v("@netsells/vue-storybook-test-utils"),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("Most of your test composition and variants (e.g. props, slots) is already setup as part of storybook for use in component-first development and Visual Regression Testing process. It makes little sense to do this setup twice. This module allows you to pass your stories directly to the "),s("a",{attrs:{href:"https://vue-test-utils.vuejs.org/",target:"_blank",rel:"noopener noreferrer"}},[t._v("@vue/test-utils"),s("OutboundLink")],1),t._v(" package and have the wrappers automatically generated with your provided props and story markup.")]),t._v(" "),s("p",[t._v("For further details and usage check out the module README.")]),t._v(" "),s("h2",{attrs:{id:"format"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#format","aria-hidden":"true"}},[t._v("#")]),t._v(" Format")]),t._v(" "),s("h3",{attrs:{id:"file-convention"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#file-convention","aria-hidden":"true"}},[t._v("#")]),t._v(" File Convention")]),t._v(" "),s("p",[t._v("Test files should be suffixed with "),s("code",[t._v(".spec.js")]),t._v(" and should match the name of the file being tested. They should be placed alongside the source file in your application. For example, if we were to have a "),s("code",[t._v("TextInput.vue")]),t._v(" component, our file structure would look something like so:")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("├─ TextInput/\n│  ├─ TextInput.vue\n│  ├─ TextInput.spec.js\n│  └─ TextInput.stories.js\n")])])]),s("p",[t._v("Doing so makes it easier to see where the tests are located for each part of your application.")]),t._v(" "),s("h3",{attrs:{id:"test-structure"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#test-structure","aria-hidden":"true"}},[t._v("#")]),t._v(" Test Structure")]),t._v(" "),s("p",[t._v("It’s recommended that you structure your tests similar to a UAT. For example, at the root level you would specify your component, and then you would nest your tests as if they were a written sentence. For example, take the following sentence:")]),t._v(" "),s("blockquote",[s("p",[s("strong",[t._v("On the TextInput component, when the "),s("code",[t._v("disabled")]),t._v(" prop is passed, the input will become disabled.")])])]),t._v(" "),s("p",[t._v("What we end up with are three pieces of information.")]),t._v(" "),s("ul",[s("li",[t._v("The "),s("badge",{attrs:{vertical:"middle"}},[t._v("entity")]),t._v(" being tested: "),s("code",[t._v("TextInput")])],1),t._v(" "),s("li",[t._v("The "),s("badge",{attrs:{vertical:"middle"}},[t._v("functionality")]),t._v(" being tested: the "),s("code",[t._v("disabled")]),t._v(" prop being passed")],1),t._v(" "),s("li",[t._v("The desired "),s("badge",{attrs:{vertical:"middle"}},[t._v("outcome")]),t._v(": the input will become disabled")],1)]),t._v(" "),s("p",[t._v("Given, this information we can structure our test like so:")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("describe")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'TextInput'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// the entity")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("describe")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'when the `disabled` prop is provided'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// the functionality")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("test")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'the input is disabled'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// the outcome")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Run tests to satisfy the UAT")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("The idea behind this format is to avoid cases where you might have a test named "),s("code",[t._v("updates data appropriately")]),t._v(". What does “appropriately” mean? If a new developer were to modify this component and update the test in future would they know what the individual requirements of the component are?")]),t._v(" "),s("p",[t._v("Eventually you will end up with a complete, living UAT document within the codebase.")]),t._v(" "),s("h3",{attrs:{id:"fixtures"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#fixtures","aria-hidden":"true"}},[t._v("#")]),t._v(" Fixtures")]),t._v(" "),s("p",[t._v("When testing against data, rather than hardcoding your data within your test, it's better to move this data to a "),s("code",[t._v("fixture")]),t._v(". A fixture is an immutable dataset that your tests are based on to mimic real data. For instance if you have a component which takes data from an endpoint and populates a users table, you might have a "),s("code",[t._v("users.json")]),t._v(" fixture with your static data. You would then pull this into your test instead.")]),t._v(" "),s("p",[t._v("Fixtures should be placed in "),s("code",[t._v("<root>/tests/fixtures/")]),t._v(".")]),t._v(" "),s("div",{staticClass:"custom-block warning"},[s("p",{staticClass:"custom-block-title"},[t._v("WARNING")]),t._v(" "),s("p",[t._v("It's important that your fixture remains immutable as to not introduce any essence of unpredictability into your tests")])])])},[],!1,null,null,null);e.default=n.exports}}]);