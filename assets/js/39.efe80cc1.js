(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{242:function(e,t,o){"use strict";o.r(t);var a=o(0),s=Object(a.a)({},function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h1",{attrs:{id:"testing-flutter-apps"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#testing-flutter-apps","aria-hidden":"true"}},[e._v("#")]),e._v(" Testing Flutter Apps")]),e._v(" "),o("p",[e._v("Comprehensive automated tests are a crucial component of a healthy codebase. Not only do they allow behaviour to be continuously verified as changes are made to a project; they also encourage good development habits, boost productivity, and serve as living documentation for the intended functionality of your code.")]),e._v(" "),o("p",[e._v("Thankfully, Flutter's testing APIs make it easy to write a comprehensive test suite.")]),e._v(" "),o("p",[o("strong",[e._v("Summary")])]),e._v(" "),o("ul",[o("li",[e._v('Use a "given-when-then" structure for tests')]),e._v(" "),o("li",[e._v("Aim for 100% test coverage")]),e._v(" "),o("li",[e._v("Bake testing into your development workflow")]),e._v(" "),o("li",[e._v("Review tests in PRs carefully")]),e._v(" "),o("li",[e._v("Don't skip tests to save time")])]),e._v(" "),o("h2",{attrs:{id:"üß™-formula-for-a-good-test"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#üß™-formula-for-a-good-test","aria-hidden":"true"}},[e._v("#")]),e._v(" üß™ Formula for a good test")]),e._v(" "),o("p",[e._v("A good test has 3 steps:")]),e._v(" "),o("ol",[o("li",[e._v("Set up")]),e._v(" "),o("li",[e._v("Act")]),e._v(" "),o("li",[e._v("Assert")])]),e._v(" "),o("p",[e._v('This can also be thought of as a "given-when-then" structure. For example:')]),e._v(" "),o("blockquote",[o("p",[o("strong",[e._v("Given")]),e._v(" the Home screen is displayed, "),o("strong",[e._v("when")]),e._v(" I tap the Floating Action Button, "),o("strong",[e._v("then")]),e._v(" the Add Todo widget should be displayed.")])]),e._v(" "),o("p",[e._v("Here are some signs you might be writing a bad test:")]),e._v(" "),o("ul",[o("li",[e._v("The goal of the test is unclear")]),e._v(" "),o("li",[e._v("The test has multiple reasons to fail")]),e._v(" "),o("li",[e._v("The test contains artificial delays")]),e._v(" "),o("li",[e._v("The test has hidden or internal dependencies")]),e._v(" "),o("li",[e._v("There are no assertions, expectations, of verifications")]),e._v(" "),o("li",[e._v("The order in which a test is executed affects its result")])]),e._v(" "),o("h2",{attrs:{id:"üíØ-aim-for-100-test-coverage"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#üíØ-aim-for-100-test-coverage","aria-hidden":"true"}},[e._v("#")]),e._v(" üíØ Aim for 100% test coverage")]),e._v(" "),o("p",[e._v("Test coverage is a fairly blunt measure of how effective your tests are, but it's the best one we have. Increasing test coverage can never be a bad thing, and the higher the coverage, the more confident we can be in our code.")]),e._v(" "),o("p",[e._v("We expect 100% test coverage in our new projects. Any less than 100% coverage makes a test suite limited in its usefulness; with 100% coverage you can be extremely confident in the continuous correctness of the codebase as changes are made and new features added.")]),e._v(" "),o("p",[o("em",[e._v("Note: generated code is excluded from our test coverage measurements; only handwritten code is measured.")])]),e._v(" "),o("p",[e._v("We measure test coverage in projects using "),o("a",{attrs:{href:"https://coveralls.io",target:"_blank",rel:"noopener noreferrer"}},[e._v("Coveralls"),o("OutboundLink")],1),e._v(". Each time you open a PR, Coveralls will look at your coverage and notify you if coverage is less than 100%.")]),e._v(" "),o("h4",{attrs:{id:"why-not-80-or-90"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#why-not-80-or-90","aria-hidden":"true"}},[e._v("#")]),e._v(" Why not 80% or 90%?")]),e._v(" "),o("p",[e._v("In our experience, aiming for less than 100% means that the easiest code to test is covered, but the more complex code is not. This often results in the code most in need of test coverage not being covered!")]),e._v(" "),o("p",[e._v("In addition, maintaining a project at 100% coverage is much easier than maintaining a project with less. If you start with 100% and it drops, the next step is easy: test the uncovered code. If you start with 80% and it drops, you have to begin by figuring out which bit of the code wasn't covered before, and why, before you can continue.")]),e._v(" "),o("h4",{attrs:{id:"won-t-this-take-loads-of-extra-time"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#won-t-this-take-loads-of-extra-time","aria-hidden":"true"}},[e._v("#")]),e._v(" Won't this take loads of extra time?")]),e._v(" "),o("p",[e._v("If you're not used to baking testing into your workflow, it may take a little time to adjust. But any untested code is technical debt, which must be paid back with interest in the future.")]),e._v(" "),o("h4",{attrs:{id:"tips-for-100-coverage"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#tips-for-100-coverage","aria-hidden":"true"}},[e._v("#")]),e._v(" Tips for 100% coverage")]),e._v(" "),o("ul",[o("li",[e._v("If you're struggling, bring in another developer to help")]),e._v(" "),o("li",[e._v("Use "),o("a",{attrs:{href:"https://api.flutter.dev/flutter/flutter_test/matchesGoldenFile.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("golden tests"),o("OutboundLink")],1),e._v(" as a quick way of verifying the visual design and layout of a widget")]),e._v(" "),o("li",[e._v("Use feature-level integration tests to cover lines which are harder to cover with just unit tests")]),e._v(" "),o("li",[e._v("Don't slowly build up to 100% at the start of the project; the codebase should be 100% covered from the very first commit")]),e._v(" "),o("li",[e._v("For code which genuinely cannot be tested (e.g. packages which use top-level or static methods, or platform channels), wrap the functionality in a mockable class and add this comment to the top of the file: "),o("code",[e._v("// coverage:ignore-file")]),e._v(". This excludes the file from being included in coverage measurements. "),o("strong",[e._v("Watch out for abuses of this functionality when reviewing PRs!")])])]),e._v(" "),o("h2",{attrs:{id:"üßÅ-bake-testing-into-your-development-workflow"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#üßÅ-bake-testing-into-your-development-workflow","aria-hidden":"true"}},[e._v("#")]),e._v(" üßÅ Bake testing into your development workflow")]),e._v(" "),o("p",[e._v("Tests are easiest to write when the functionality under test is already in your mind. It's much more taxing to go back and write tests for a bunch of functionality you wrote a few days or weeks ago.")]),e._v(" "),o("p",[e._v("To that end, bake testing into your development workflow. You could use a framework like Test-driven Development (TDD), or simply write tests for each class immediately after you've written the production code. Do whatever works for you.")]),e._v(" "),o("p",[e._v("In any case, when it's time to open your Pull Request you should ensure you're meeting the requirement for 100% coverage, and that all tests are passing.")]),e._v(" "),o("h2",{attrs:{id:"üî¨-review-tests-in-prs-carefully"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#üî¨-review-tests-in-prs-carefully","aria-hidden":"true"}},[e._v("#")]),e._v(" üî¨ Review tests in PRs carefully")]),e._v(" "),o("p",[e._v("Even with 100% line coverage, it's extremely important that tests are reviewed manually during the code review process. When reviewing tests, look out for these red flags:")]),e._v(" "),o("ul",[o("li",[e._v("Tests with no assertions, expectations, or verifications")]),e._v(" "),o("li",[e._v("Tests which have obviously been written just to satisfy the coverage requirement")]),e._v(" "),o("li",[e._v("Not all logical branches are tested (e.g. only the right-hand-side of a ternary operator)")]),e._v(" "),o("li",[e._v('Only testing the "happy path"')]),e._v(" "),o("li",[e._v("Abuses of the "),o("code",[e._v("// coverage:ignore-file")]),e._v(" rule")])]),e._v(" "),o("h2",{attrs:{id:"‚åõ-don-t-skip-tests-to-save-time"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#‚åõ-don-t-skip-tests-to-save-time","aria-hidden":"true"}},[e._v("#")]),e._v(" ‚åõ Don't skip tests to save time")]),e._v(" "),o("p",[e._v("Skipping tests saves you time today, but this time saving doesn't come for free. You exchange this time for technical debt.")]),e._v(" "),o("p",[e._v("Fundamentally, an untested codebase cannot scale efficiently, and will become more and more difficult to work with over time. The time you save now by not writing a test will need to be paid back - with significant interest - later down the line.")]),e._v(" "),o("p",[e._v('Be firm on this principle when working with non-technical staff. Project timelines should and must include sufficient time for developers to write high-quality, well-tested code, and any estimates you give must include time for adding/updating tests. There is no such thing as "pushing to get this over the line"; writing good code takes as long as it needs to.')])])},[],!1,null,null,null);t.default=s.exports}}]);